#pragma config(Sensor, in1,    pot,            sensorPotentiometer)
#pragma config(Sensor, dgtl1,  driveSense,     sensorQuadEncoder)
#pragma config(Motor,  port1,           rightTop,      tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           rightBottom,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           leftTop,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           leftBottom,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           lift,          tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*GOALS (initial)
to code a viable auton for a bot that can onbly stack on mogos
- !!!find dist from starting position to mogo //2063.69427 encoder val
- !!!measure how low we have to lower lift to put preload cone onto mogo
- drive to mogo
- lower lift onto mogo (effectively stacking cone onto it)
- lift returns to relaxed position
- bot returns for parking bonus
*/

float dist = (72/(4*3.14159265))*360;
float encoderVal = 0; 
int target = 0; //tbd after testing 

void turnOnDriveMotors(){
	motor[rightTop] = 127;
	motor[rightBottom] = 127;
	motor[leftTop] = 127;
	motor[leftBottom] = 127;
}
void turnOffDriveMotors(){
	motor[rightTop] = 0;
	motor[rightBottom] = 0;
	motor[leftTop] = 0;
	motor[leftBottom] = 0;
}
void reverseDriveMotors(){
	motor[rightTop] = -127;
	motor[rightBottom] = -127;
	motor[leftTop] = -127;
	motor[leftBottom] = -127;
}

task main()
{

	SensorValue[driveSense] = 0;
	while(true){
		float error = /*target-*/ SensorValue[pot] ;
		encoderVal = SensorValue[driveSense];

		while(encoderVal < dist)
		{
			turnOnDriveMotors();
		}
		turnOffDriveMotors();
		//SensorValue[driveSense] = 0;
		//encoderVal = SensorValue[driveSense];
		// lower lift need nums

		motor[lift] = 0.1 * error;
		while(encoderVal > /*-dist*/ 0)
		{
			reverseDriveMotors();
		}
		turnOffDriveMotors();

	}


}
