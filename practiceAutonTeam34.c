#pragma config(Sensor, in1,    pot,            sensorPotentiometer)
#pragma config(Sensor, dgtl1,  driveSense,     sensorQuadEncoder)
#pragma config(Motor,  port1,           rightTop,      tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           rightBottom,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           leftTop,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           leftBottom,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           mogoLift,          tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*GOALS (initial)
to code a viable auton for a bot that can onbly stack on mogos
- !!!find dist from starting position to mogo //2063.69427 encoder val
- !!!measure how low we have to lower lift to put preload cone onto mogo
- drive to mogo
- lower lift onto mogo (effectively stacking cone onto it)
- lift returns to relaxed position
- bot returns for parking bonus
*/

float dist = (72/(4*3.14159265))*360; // encoder val when reached to destination
float encoderVal = 0; 
int target = 0; //tbd after testing 

void turnOnDriveMotors(){
	motor[rightTop] = 127;
	motor[rightBottom] = 127;
	motor[leftTop] = 127;
	motor[leftBottom] = 127;
}
void turnOffDriveMotors(){
	motor[rightTop] = 0;
	motor[rightBottom] = 0;
	motor[leftTop] = 0;
	motor[leftBottom] = 0;
}
void reverseDriveMotors(){
	motor[rightTop] = -127;
	motor[rightBottom] = -127;
	motor[leftTop] = -127;
	motor[leftBottom] = -127;
}

task main()
{

	SensorValue[driveSense] = 0;
	while(true){
		float error = target- SensorValue[pot] ;
		encoderVal = SensorValue[driveSense];
		// float errorDrive = targetDrive - SensorValue[driveSense];
		//replace all encodervals with errorDrive
		// encodetVal = 0.1 * errorDrive;

		while(encoderVal < dist)
		{
			turnOnDriveMotors(); 
			//drive to desired location
		}
		turnOffDriveMotors();
		SensorValue[driveSense]/*or encoderVal*/ = 0;
		encoderVal = SensorValue[driveSense];/*or the error tjing ahain*/
		// lower lift need nums

		motor[mogoLift] = 0.1 * error;
		wait(
		while(encoderVal > /*-dist*/ 0)
		{
			reverseDriveMotors();
		}
		turnOffDriveMotors();
		//turn robot to place mogo in 10 pt zone POINT TURN (wheels go in opp directions)
		//call turn function abt 135 deg
		// Lower mogo lift

	}

/*
Auton1 Plan:
- TEST encoder to see the val we need it to go to to get to the mogo 
- drive forward til encoder val is hit (pid necessary?)
- TEST pot to see the val we need it to go to to lift mogo/stacl
- TEST --^
- lift til pot reaches chosen val (PID)
- drive backward til encoder val is hit(or neg of it)
- TEST encoder val needed to place mogo in x-pt zone
- drive til mogo is over pt zone
- lower lift til previous pot value is reached/negPotVal reached
- drive negSecondEncoder val to orginal position // PARK

Auton2 Plan: (in case alliance runs placing in 20pt zone)
- SAME as Auton1 but in 10pt zone

Auton3 Plan: (for stack bonus?)
- same as first half of Auton1
- stack onto mogo
~ OR ~
- stack onto stationary goal
g o  f o r  t h e  g o (a) l d

*/
}
